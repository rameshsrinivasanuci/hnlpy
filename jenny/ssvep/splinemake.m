%% mat = splinemake(e,es,k,ks)%% SPLINEMAKE creates a transform matrix for a least-squares spline% approximation of an operation (e.g. interpolation, Laplacian, gradient)% on a set of data:%% newdata = (es*inv(e'*inv(k)*e)*e'*inv(k) ...%         + ks*inv(k)*(v - e*inv(e'*inv(k)*e)*e'*inv(k))*data;%         = mat*data;%%   e: n x 10 osculating function in original channel space%  es: ns x 10 transform of osculating function in (new) channel space%   k: n x n spline distance matrix in original vector space%  ks: ns x n transform of spline distance matrix in (new) channel space%% mat: ns x n spline transform matrix%% See also: SPLINENLAP, SPLINEINTERP%% Copyright (C) 2009 Bill Winter, <wwinter@hs.uci.edu>%% This program is free software: you can redistribute it and/or modify% it under the terms of the GNU General Public License as published by% the Free Software Foundation, either version 3 of the License, or% (at your option) any later version.%% This program is distributed in the hope that it will be useful,% but WITHOUT ANY WARRANTY; without even the implied warranty of% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the% GNU General Public License for more details.%% You should have received a copy of the GNU General Public License% along with this program.  If not, see <http://www.gnu.org/licenses/>.%% Written by Bill Winter, August 2009function varargout = splinemake(e,es,k,ks,varargin)[ns n] = size(ks);if size(es,1) ~= ns || size(e,1) ~= n || size(es,2) ~= size(e,2) || ...        any(size(k) ~= n)    error('size incompatibility in splinemake');end[v siz] = splinecheck(varargin{:});m = size(v,2);if m > n                        % many frames to convert    vs = v;    v = eye(n);endif length(k) < 500                  % need to find a better way of handling    [u s] = eig(k);                 % u*d*u' = k; consider replacing with ldl    in = abs(diag(s));    in = find(in  > eps(max(in))*length(in));    if length(in) < n               % rank deficient k        u = u(:,in);        k = s(in,in);        e = u'*e;        ks = ks*u;        v = u'*v;    endendke = k\e;mat = e'*ke;[u s] = eig(mat);               % u*s*u' = e'*inv(k)*ein = abs(diag(s));in = find(in  > eps(max(in))*length(in));if length(in) < size(e,2);      % rank deficient e    u = u(:,in);    mat = s(in,in);    ke = ke*u;    e = e*u;    es = es*u;endmat = mat\ke'*v;if ns <= n, mat = es*mat + (ks/k)*(v - e*mat);else        mat = es*mat + ks*((k\v) - ke*mat);endif m > n, mat = mat*vs; endif isempty(siz), varargout = {mat};else    varargout = mat2cell(mat,ns,cellfun(@prod,siz)/ns);    for k = 1:length(varargout)        varargout{k} = reshape(varargout{k},siz{k});    endend% If the spline is meant to be applied to any data, splinecheck makes% sure that the data is of a compatible size    function [v siz] = splinecheck(varargin)        siz = cell(1,length(varargin));        if nargin < 1, v = eye(n);        else            for kk = 1:nargin                siz{kk} = size(varargin{kk});                if siz{kk}(1) ~= n                    % check if the data is just a strangely shaped vector                    if sum(siz{kk} == n) == 1 && sum(siz{kk} == 1) == length(siz{kk}) - 1                        varargin{kk} = varargin{kk}(:);                        siz{kk}(siz{kk} == n) = ns;                    else                        error('data/channel incompatibility');                    end                else                    varargin{kk} = varargin{kk}(:,:);                    siz{kk}(1) = ns;                end            end            v = cell2mat(varargin(:).');        end    endend